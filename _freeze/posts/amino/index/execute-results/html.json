{
  "hash": "0deb782263feb1d6abf207ae021d6fff",
  "result": {
    "markdown": "---\ntitle: \"Analyzing the Kasa Romana Lottery with Knapsack Algorithm\"\nauthor: \"Maciej Nasinski\"\ndate: \"2023-04-09\"\ncategories: [knapsack, rprogramming]\nimage: main.png\n---\n\n\nTL;DR Suppose you want to organize a perfect lottery where people genuinely believe in winning and have no chance of winning. In that case, you need to hire a good mathematician. However, the R programmer can easily expose the mechanism with proper data.\n\n## Post\n\nKasa Romana is a popular lottery in Poland organized by the Amino food company. Established in the 90s, the lottery provides an opportunity to win real money by collecting a set of coupons that sum up to full hundreds up to 1000. In this blog post, we will analyze the data from the last Kasa Romana event held in 2016 using the Knapsack Algorithm in R.\n\n[BezKanalu](https://www.facebook.com/BezKanalu/), a popular YouTube channel in Poland that tests products during promotions, collected precisely 1002 coupons from the last event, providing a sufficient amount of data for analysis. The main objective is to find patterns in the data and determine if the collected coupons give any chance to win real money.\n\nTo achieve the goal, I used the Knapsack Algorithm, a classic optimization problem that involves finding the optimal way to pack a set of items into a limited space while maximizing their total value. In this case, the \"items\" are the coupons, and the \"limited space\" is the need to have a set of coupons that sum up to full hundreds up to 1000.\n\nI implemented the Knapsack Algorithm in R programming environment to check if there are any combinations of coupons that enable the lottery participants to win any money. The algorithm works by iterating over all possible subsets of the coupons and selecting the one that satisfies the constraints and maximizes the total value.\n\nThe analysis with 1000 coupons revealed that there are is NO combinations of coupons that enable the participants to win real money in the Kasa Romana lottery.\n\nIn conclusion, the Knapsack Algorithm is a powerful tool for solving optimization problems like the Kasa Romana lottery. By using R programming environment, I was able to analyze the data and provide valuable insights into the lottery's patterns and trends. \n\n\n## Analysis\n\n### WebR R Console to Play with the Code\n\nPlease install any needed dependency with call like `webr::install(\"dplyr\")`.  \nThe available R packages can be get with the `rownames(available.packages(repos = \"https://repo.r-wasm.org/\"))` call.  \nPlease note that the `adagio` package used later in the post is not yet available in the `webr` console.\n\n\n```{=html}\n<div style=\"border: solid #333 1px; padding: 5px; width: 1008px;\">\n  <pre id=\"loading\"><code>Loading webR, please wait...</code></pre>\n  <pre id=\"container\" style=\"max-height: 400px\"><code id=\"out\"></code></pre>\n  <div class=\"input-group mb-3\">\n    <span class=\"input-group-text\" id=\"prompt\">></span>\n    <input spellcheck=\"false\" autocomplete=\"off\" id=\"input\" type=\"text\">\n    <button type=\"button\" class=\"btn btn-secondary\" onclick=\"globalThis.sendInput()\" id=\"run\">Run</button>\n  </div>\n</div>\n<div id=\"container\" style=\"border: solid #333 1px; padding: 5px; width: 1008px;\">\n  <button type=\"button\" class=\"collapsible-item\">(Click) to Show Last Plot</button>\n  <div class=\"content-item\">\n    <canvas id=\"myCanvas\" width=\"1008px\" height=\"1008px\"></canvas>\n  </div>\n</div>\n\n<script type=\"module\">\n  import { Console } from 'https://webr.r-wasm.org/v0.1.1/webr.mjs';\n  const webRConsole = new Console({\n    stdout: line => {\n      document.getElementById('out').append(line + '\\n');\n    },\n    stderr: line => document.getElementById('out').append(line + '\\n'),\n    prompt: p => {\n      const pre = document.getElementById('container');\n      pre.scrollTop = pre.scrollHeight; \n      document.getElementById('prompt').innerText = p;\n    },\n    canvasExec: line => {\n    console.log(line);\n      var canvas = document.getElementById(\"myCanvas\");\n      console.log(`canvas.getContext('2d').${line}`);\n      eval(`canvas.getContext('2d').${line}`);\n    }\n  }, {channelType: 0, REnv: {\n        R_HOME: '/usr/lib/R',\n        R_ENABLE_JIT: '0',\n        R_DEFAULT_DEVICE: 'canvas',\n      }});\n  \n  webRConsole.run();\n  \n  let coupons_string = await fetch('./coupons.json')\n    .then((response) => response.json())\n  let start_R_code = \"coupons <- c(\" + coupons_string.toString() + \")\\n\";\n  \n  webRConsole.webR.init()\n  .then(() => document.getElementById('loading').remove())\n  .then(() => {\n    document.getElementById('out').append(\"> \" + start_R_code);\n    webRConsole.stdin(start_R_code);\n  })\n  .then(() => {\n    document.getElementById('out').append(\"> hist(coupons)\");\n    webRConsole.stdin(\"hist(coupons)\");\n  });\n\n  let input = document.getElementById('input');\n  globalThis.sendInput = () => {\n    webRConsole.stdin(input.value);\n    document.getElementById('out').append(\n      document.getElementById('prompt').innerText + ' ' + input.value + '\\n'\n    );\n    input.value = \"\";\n  }\n  input.addEventListener(\n    \"keydown\",\n    (evt) => {if(evt.keyCode === 13) globalThis.sendInput()}\n  );\n</script>\n\n<script>\n  var coll = document.getElementsByClassName(\"collapsible-item\");\n  var i;\n\n  for (i = 0; i < coll.length; i++) {\n    coll[i].addEventListener(\"click\", function() {\n      this.classList.toggle(\"active-item\");\n      var content = this.nextElementSibling;\n      if (content.style.display === \"block\") {\n        content.style.display = \"none\";\n      } else {\n        content.style.display = \"block\";\n      }\n    });\n  }\n</script>\n```\n\n\n### Static Code\n\n\n::: {.cell}\n\n:::\n\n\nSorted unique values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(unique(coupons))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  26  39  52  65  78  91 104 117 130 143 156 165 169 182 191 195 204 208 217\n[20] 221 230 234 243 247 256 260 269 273 282 286 295 299 308 312 321 325 334 338\n[39] 347 351 360 364 373 377 386 390 399 403 412 416 425 429 438 442 451 455 464\n[58] 468 477 481 490 494 503 507 516 520 529 533 542 546 555 559 568 572 581 585\n[77] 594 598 607 611 620 624 633 637 646 650 659 672 685 698 711 724 737 750\n```\n:::\n:::\n\n\nSorted table of frequencies:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(table(coupons))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncoupons\n334 403 646 204 208 360 507 620 104 234 364 481 633 698 143 247 256 269 373 377 \n  1   1   1   2   2   2   2   2   3   3   3   3   3   3   4   4   4   4   4   4 \n429 468 490 581 607 217 286 308 386 451 464 494 594 672 685 711 156 165 169 182 \n  4   4   4   4   4   5   5   5   5   5   5   5   5   5   5   5   6   6   6   6 \n221 282 299 325 399 503 559 637 724  65  91 191 230 321 338 351 416 477 516 529 \n  6   6   6   6   6   6   6   6   6   7   7   7   7   7   7   7   7   7   7   7 \n568 572 585 611 624 659 737 117 195 295 312 347  78 273 425 442 533 542 546 555 \n  7   7   7   7   7   7   7   8   8   8   8   8   9   9   9   9   9   9   9   9 \n598  39  52 520 438 243 412 650 130 390 260 455 750  26 \n  9  10  10  10  11  12  13  50  57  57  61  71  90  95 \n```\n:::\n:::\n\n\nHistrogram might be helpful to find certain patterns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(coupons, breaks = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n**Numbers seems to be generated from 2 specific patterns:**\n\n- multiplication of 13 starting from 26\n- multiplication of 13 plus 165\n\nAll of the coupons comes from this 2 sequences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep13 <- 13 * 1:52\n\nrep2_13 <- 165 + (13 * 0:45)\n\nall(coupons %in% c(rep13, rep2_13))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n*Single knapsack problem:*\n\nKnapsack is an optimization method, linear programming for integers.\n\nEach of 1000 coupons is replicated 100 times before the procedure. This replication step is not needed to get this certain results although it will be even more convincing. Remainder, I was looking for set of coupons which sum to full hundreds (100, 200, ...) up to 1000.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# adagio can not be downloaded in the WebR R console\nlibrary(adagio)\n\ncupon_we_have = rep(coupons, 100)\n\namount_we_want = seq(100, 1000, 100)\n\nfor(i in amount_we_want){\n\nsolution <- try(\n  knapsack(\n    p = cupon_we_have[cupon_we_have<i], \n    w = cupon_we_have[cupon_we_have<i], \n    cap = i\n  )\n)\n\nprint(sprintf(\"Best result for %s reward is %s\", i, solution$profit))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Best result for 100 reward is 91\"\n[1] \"Best result for 200 reward is 195\"\n[1] \"Best result for 300 reward is 299\"\n[1] \"Best result for 400 reward is 399\"\n[1] \"Best result for 500 reward is 499\"\n[1] \"Best result for 600 reward is 599\"\n[1] \"Best result for 700 reward is 699\"\n[1] \"Best result for 800 reward is 798\"\n[1] \"Best result for 900 reward is 898\"\n[1] \"Best result for 1000 reward is 998\"\n```\n:::\n:::\n\n\nTaking into account only coupons provided there is NO chance to win anything.  \nThis seems to no be surprising when we know from what sequences the coupons come from.  \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}